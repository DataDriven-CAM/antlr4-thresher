#pragma once
// generated by cantlrtool https://github.com/DataDriven-CAM/antlr4-thresher.git

{block_comment}

#include <stdlib.h>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <exception>
#include <string>
#include <iterator>
#include <locale>
#include <codecvt>
#include <cstring>
#include <cwchar>
#include <functional>

#include "parse/u16ncmp.h"

#include "graph/container/compressed_graph.hpp"
{token_vocab_include}

namespace {namespace} {{

    enum PARSER_TOKEN {{
{tokens}
    }};

    struct parser_node{{
      PARSER_TOKEN parser_token;
      LEXER_TOKEN token;
      MODE mode=MODE::DEFAULT;
    }};


    using PG = graph::container::compressed_graph<int, parser_node>;

    class {class}{{
    protected:
        PG dagGraph;
        std::vector<ast_node> vertices;
        std::vector<std::tuple<graph::vertex_id_t<PG>, graph::vertex_id_t<PG>, int>> edges;
        
        {token_vocab_class} {token_vocab_instance};
    
    public:
        {class}() = default;
        {class}(const {class}& orig) = delete;
        virtual ~{class}() = default;

        //lexer rules
{lexer_rules}

        //parser rules
{parser_rules}

    void operator()(std::u16string& utf16, std::function<void(PG& dagGraph)> apply){{
        vertices.push_back({{.token=LEXER_ROOT}});
{rules_ladder}
        apply(dagGraph);
    }};

    
    std::u16string::const_iterator itEnd;
    bool EndOfFile(std::u16string::const_iterator& it){{
        return it==itEnd;
    }};


    }};
}}
